package SW
public
	with Data_Model;

	with Base_Types;

	with CASE_Prop;

	with SW_CASE_Claims;

	-- This is the structure to hold the lat/long/alt values of a coordinate
	data Coordinate
	end Coordinate;

	data implementation Coordinate.Impl
		subcomponents
			latitude: data Base_Types::Integer;
			longitude: data Base_Types::Integer;
			altitude: data Base_Types::Integer;
	end Coordinate.Impl;

		-- The Map is a structure that contains a list of coordinates that encircle a
		-- region.  
		-- In this implementation, we fix the size of the map to 4 waypoints
		-- Future versions will use an array
	data Map
	end Map;

	data implementation Map.Impl
		subcomponents
			wp1: data Coordinate.Impl;
			wp2: data Coordinate.Impl;
			wp3: data Coordinate.Impl;
			wp4: data Coordinate.Impl;
	end Map.Impl;

		-- The MapArray is a structure that hold multiple Maps
		-- In this implementation, we fix the size of the map array to 5 maps
		-- Future versions will use an array
	data MapArray
	end MapArray;

	data implementation MapArray.Impl
		subcomponents
			map1: data Map.Impl;
			map2: data Map.Impl;
			map3: data Map.Impl;
			map4: data Map.Impl;
			map5: data Map.Impl;
	end MapArray.Impl;

		-- The Flight Pattern is an enumeration that defines how the UAV will fly through the
		-- sensing region to conduct surveillance.
	data FlightPattern
		properties
			Data_Model::Data_Representation => Enum;
			Data_Model::Enumerators => ("ZigZag", "StraightLine", "Perimeter");
	end FlightPattern;

	data implementation FlightPattern.Impl
	end FlightPattern.Impl;

		-- The Command structure contains data that the Ground Station passes to the UAV.
		-- It contains a Map, Flight Pattern and Authentication bit.
	data Command
	end Command;

	data implementation Command.Impl
		subcomponents
			Map: data Map.Impl;
			Pattern: data FlightPattern;
			HMAC: data Base_Types::Boolean;
	end Command.Impl;

		-- The Mission is a list of waypoints that is generated by the Flight Planner based on a
		-- Map and Flight Pattern.
		-- For this implementation, we fix the size of the Mission to 10 waypoints.
		-- Future versions will use an array
	data Mission
	end Mission;

	data implementation Mission.Impl
		subcomponents
			wp1: data Coordinate.Impl;
			wp2: data Coordinate.Impl;
			wp3: data Coordinate.Impl;
			wp4: data Coordinate.Impl;
			wp5: data Coordinate.Impl;
			wp6: data Coordinate.Impl;
			wp7: data Coordinate.Impl;
			wp8: data Coordinate.Impl;
			wp9: data Coordinate.Impl;
			wp10: data Coordinate.Impl;
	end Mission.Impl;

		-- The Mission Window is a list of waypoints that the Waypoint Manager assembles from
		-- the Mission.
		-- For this implementation, we fix the size of the Mission Window to 4 waypoints.
		-- The crc value is an abstraction for data integrity, which, if true, tells us that the data has not
		-- been corrupted.
	data MissionWindow
	end MissionWindow;

	data implementation MissionWindow.Impl
		subcomponents
			wp1: data Coordinate.Impl;
			wp2: data Coordinate.Impl;
			wp3: data Coordinate.Impl;
			wp4: data Coordinate.Impl;
			crc: data Base_Types::Boolean;
	end MissionWindow.Impl;

		-- The WifiDriver is the software that enables other SW components to communicate to other systems over WiFi
	thread WifiDriver
		features
			gimbal_command_in: in event data port;
			gimbal_command_out: out event data port;
	end WifiDriver;

	thread implementation WifiDriver.Impl
	end WifiDriver.Impl;

		-- The RadioDriver is the software that enables other SW components to communicate to other systems over RF
	thread RadioDriver
		features
			attestation_request_in: in event data port;
			attestation_request_out: out event data port;
			attestation_response_in: in event data port;
			attestation_response_out: out event data port;
			recv_map_in: in event data port Command.Impl;
			send_status_out: out event data port Coordinate.Impl;
			send_status_in: in event data port Coordinate.Impl;
			recv_map_out: out event data port Command.Impl;
		annex agree {**
			assume Req001_RadioDriver "Authenticated command from the Ground Station" : recv_map_in.HMAC = True;
			guarantee Req002_RadioDriver "Authenticated command from the Ground Station" : recv_map_out.HMAC = True;
		**};
	end RadioDriver;

	thread implementation RadioDriver.Impl
	end RadioDriver.Impl;

	thread AttestationManager
		features
			attestation_request: out event data port;
			attestation_response: in event data port;
			message_in: in event data port Command.Impl;
			message_out: out event data port Command.Impl;
		properties
			CASE_Prop::CACHE_TIMEOUT => 60;
		annex agree {**
			assume Req001_AttestationManager "Authenticated command from the Ground Station" : message_in.HMAC = True;
			guarantee Req002_AttestationManager "Authenticated command from the Ground Station" : message_out.HMAC = True;
		**};
	end AttestationManager;

	thread implementation AttestationManager.Impl
	end AttestationManager.Impl;

		-- The FlightPlanner is an abstraction for UxAS.
		-- It accepts a command message containing a map and flight pattern, and generates a mission.
		-- The FlightPlanner also has access to a No-Fly zone database, which it uses to generate the mission 
		-- to avoid specified no-fly zones
	thread CASE_Filter
		features
			filter_in: in event data port Command.Impl;
			filter_out: out event data port Command.Impl;
		properties
			CASE_Prop::COMP_TYPE => FILTER;
			CASE_Prop::COMP_IMPL => "CakeML";
			CASE_Prop::COMP_SPEC => "Req002_Filter";
		annex agree {**
			assume Req001_Filter "Authenticated command from the Ground Station" : filter_in.HMAC = True;
			guarantee Req002_Filter "Well-formed messages from the Ground Station" : good_command(filter_out);
			guarantee Req003_RadioDriver "Authenticated command from the Ground Station" : filter_out.HMAC = True;
		**};
	end CASE_Filter;

	thread implementation CASE_Filter.Impl
	end CASE_Filter.Impl;

		-- The FlightPlanner is an abstraction for UxAS.
		-- It accepts a command message containing a map and flight pattern, and generates a mission.
		-- The FlightPlanner also has access to a No-Fly zone database, which it uses to generate the mission 
		-- to avoid specified no-fly zones
	thread FlightPlanner
		features
			flight_plan: out data port Mission.Impl;
			recv_map: in event data port Command.Impl;
			request_nofly_zones: out event data port Map.Impl;
			nofly_zones: in event data port MapArray.Impl;
			position_status: in event data port Coordinate.Impl;
		annex agree {**
			assume Req001_FlightPlanner "The FlightPlanner shall receive a well-formed command from the GroundStation" : good_command(recv_map);
			assume Req002_FlightPlanner "The Flight Planner shall receive an authenticated command from the Ground Station" : recv_map.HMAC = True;
			guarantee Req003_FlightPlanner "The Flight Planner shall generate a valid mission" : good_mission(flight_plan);
		**};
		annex resolute {**
			prove(well_formed(this, "Req001_FlightPlanner", Command.Impl))
		**};
	end FlightPlanner;

	thread implementation FlightPlanner.Impl
	end FlightPlanner.Impl;

		-- The NoFlyZoneDatabase is a collection of polygons that represent areas on a map which the UAV should avoid.
		-- The database is populated at build-time and stored in memory.
		-- When provided a map of a region, it will return all no-fly areas within that region.
	thread NoFlyZoneDatabase
		features
			map: in event data port Map.Impl;
			zones: out event data port MapArray.Impl;
	end NoFlyZoneDatabase;

	thread implementation NoFlyZoneDatabase.Impl
	end NoFlyZoneDatabase.Impl;

		-- The WaypointManager divides a mission into a small window of waypoints suitable for the FlightController.
		-- Because the FlightController can only process a small number of waypoints at a time, the WaypointManager
		-- creates these mission windows in response to the current position of the UAV, provided by the FlightController GPS.
	thread WaypointManager
		features
			flight_plan: in data port Mission.Impl;
			waypoint: out event data port MissionWindow.Impl;
			position_status: in event data port Coordinate.Impl;
		annex agree {**
			assume Req001_WaypointManager "The Waypoint Manager shall receive a well-formed mission" : good_mission(flight_plan);
			guarantee Req002_WaypointManager "The Waypoint Manager shall output a well-formed mission window" : good_mission_window(waypoint);
		**};
	end WaypointManager;

	thread implementation WaypointManager.Impl
	end WaypointManager.Impl;

		-- The CameraManager determines the gimbal settings for the onboard camera based on the current position of the UAV and the mission.
		-- The CameraManager then sends out gimbal commands to the camera over the wifi connection
	thread CameraManager
		features
			flight_plan: in data port Mission.Impl;
			position_status: in event data port Coordinate.Impl;
			gimbal_command: out event data port;
	end CameraManager;

	thread implementation CameraManager.Impl
	end CameraManager.Impl;

		-- The UARTDriver is the software that enables other SW components to communicate to other systems over the serial connection
	thread UARTDriver
		features
			position_status_in: in event data port Coordinate.Impl;
			waypoint_out: out event data port MissionWindow.Impl;
			position_status_out: out event data port Coordinate.Impl;
			waypoint_in: in event data port MissionWindow.Impl;
		annex agree {**
			assume Req001_UARTDriver "Well-formed mission window" : good_mission_window(waypoint_in);
			guarantee Req002_UARTDriver "A CRC shall be appended to the message to determine message correctness" : waypoint_out.crc = true;
		**};
	end UARTDriver;

	thread implementation UARTDriver.Impl
	end UARTDriver.Impl;

		-- The Mission Computer Software process runs all threads
	process MC_SW
		features
			recv_map: in event data port Command.Impl;
			send_status: out event data port Coordinate.Impl;
			waypoint: out event data port MissionWindow.Impl;
			position_status: in event data port Coordinate.Impl;
			gimbal_command: out event data port;
			attestation_request: out event data port;
			attestation_response: in event data port;
		annex agree {**
			assume Req001_MC_SW "The Mission Computer shall only accept authenticated commands from the Ground Station" : recv_map.HMAC = True;
			guarantee Req002_MC_SW "The Mission Computer shall output a valid mission window to the Flight Controller" : waypoint.crc = True;
		**};
	end MC_SW;


	-- This SW architecture is the result of a model transformation to address a TA1 requirement
	-- that messages must be well formed.  To address message well-formedness, a filter has been
	-- inserted in front of the Flight Planner.
	process implementation MC_SW.Impl1
		subcomponents
			RADIO: thread RadioDriver.Impl;
			RA: thread AttestationManager.Impl;
			FLT: thread CASE_Filter.Impl;
			FPLN: thread FlightPlanner.Impl;
			WPM: thread WaypointManager.Impl;
			CM: thread CameraManager.Impl;
			UART: thread UARTDriver.Impl;
			WIFI: thread WifiDriver.Impl;
			NFDB: thread NoFlyZoneDatabase.Impl;
		connections
			c1: port recv_map -> RADIO.recv_map_in;
			c2: port RADIO.send_status_out -> send_status;
			c3: port RADIO.recv_map_out -> RA.message_in;
			c4: port RA.message_out -> FLT.filter_in;
			c22: port FLT.filter_out -> FPLN.recv_map;
			c5: port FPLN.flight_plan -> WPM.flight_plan;
			c6: port FPLN.request_nofly_zones -> NFDB.map;
			c7: port NFDB.zones -> FPLN.nofly_zones;
			c8: port WPM.waypoint -> UART.waypoint_in;
			c9: port UART.position_status_out -> WPM.position_status;
			c10: port UART.position_status_out -> FPLN.position_status;
			c11: port UART.position_status_out -> RADIO.send_status_in;
			c12: port UART.waypoint_out -> waypoint;
			c13: port position_status -> UART.position_status_in;
			c14: port FPLN.flight_plan -> CM.flight_plan;
			c15: port UART.position_status_out -> CM.position_status;
			c16: port CM.gimbal_command -> WIFI.gimbal_command_in;
			c17: port WIFI.gimbal_command_out -> gimbal_command;
			c18: port RA.attestation_request -> RADIO.attestation_request_in;
			c19: port RADIO.attestation_response_out -> RA.attestation_response;
			c20: port RADIO.attestation_request_out -> attestation_request;
			c21: port attestation_response -> RADIO.attestation_response_in;
	end MC_SW.Impl1;


	-- This is the original SW architecture model before CASE TA1 Requirements tools have been applied.
	process implementation MC_SW.Impl
		subcomponents
			RADIO: thread RadioDriver.Impl;
			RA: thread AttestationManager.Impl;
			FPLN: thread FlightPlanner.Impl;
			WPM: thread WaypointManager.Impl;
			CM: thread CameraManager.Impl;
			UART: thread UARTDriver.Impl;
			WIFI: thread WifiDriver.Impl;
			NFDB: thread NoFlyZoneDatabase.Impl;
		connections
			c1: port recv_map -> RADIO.recv_map_in;
			c2: port RADIO.send_status_out -> send_status;
			c3: port RADIO.recv_map_out -> RA.message_in;
			c4: port RA.message_out -> FPLN.recv_map;
			c5: port FPLN.flight_plan -> WPM.flight_plan;
			c6: port FPLN.request_nofly_zones -> NFDB.map;
			c7: port NFDB.zones -> FPLN.nofly_zones;
			c8: port WPM.waypoint -> UART.waypoint_in;
			c9: port UART.position_status_out -> WPM.position_status;
			c10: port UART.position_status_out -> FPLN.position_status;
			c11: port UART.position_status_out -> RADIO.send_status_in;
			c12: port UART.waypoint_out -> waypoint;
			c13: port position_status -> UART.position_status_in;
			c14: port FPLN.flight_plan -> CM.flight_plan;
			c15: port UART.position_status_out -> CM.position_status;
			c16: port CM.gimbal_command -> WIFI.gimbal_command_in;
			c17: port WIFI.gimbal_command_out -> gimbal_command;
			c18: port RA.attestation_request -> RADIO.attestation_request_in;
			c19: port RADIO.attestation_response_out -> RA.attestation_response;
			c20: port RADIO.attestation_request_out -> attestation_request;
			c21: port attestation_response -> RADIO.attestation_response_in;
	end MC_SW.Impl;
	

	annex agree {**
			
		-- These functions check the well-formedness of message structures
		fun good_coordinate(coord : Coordinate.Impl) : bool =	coord.latitude >= -90 and 
																	coord.latitude <= 90 and 
																	coord.longitude >= -180 and 
																	coord.longitude <= 180 and 
																	coord.altitude >= 0 and 
																	coord.altitude <= 15000;
																	
		fun good_map(map : Map.Impl) : bool =	good_coordinate(map.wp1) and 
													good_coordinate(map.wp2) and 
													good_coordinate(map.wp3) and 
													good_coordinate(map.wp4);
													
		fun good_pattern(pattern : FlightPattern.Impl) : bool =	(pattern = enum(FlightPattern, ZigZag)) or 
																(pattern = enum(FlightPattern, StraightLine)) or 
																(pattern = enum(FlightPattern, Perimeter));
																
		fun good_HMAC(hmac : bool) : bool = (hmac = True) or (hmac = False);
		
		fun good_command(cmd : Command.Impl) : bool =	good_map(cmd.Map) and 
																good_pattern(cmd.Pattern) and 
																good_HMAC(cmd.HMAC);
																
		fun good_mission(mission : Mission.Impl) : bool =	good_coordinate(mission.wp1) and 
																good_coordinate(mission.wp2) and 
																good_coordinate(mission.wp3) and 
																good_coordinate(mission.wp4) and 
																good_coordinate(mission.wp5) and 
																good_coordinate(mission.wp6) and 
																good_coordinate(mission.wp7) and 
																good_coordinate(mission.wp8) and 
																good_coordinate(mission.wp9) and 
																good_coordinate(mission.wp10);
																
		fun good_mission_window(win : MissionWindow.Impl) : bool =	good_coordinate(win.wp1) and 
																		good_coordinate(win.wp2) and 
																		good_coordinate(win.wp3) and 
																		good_coordinate(win.wp4);
	**};
end SW;